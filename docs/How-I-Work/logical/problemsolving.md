# Problem Solving

Repairing, fixing, and problem solving is probably one of my strongest traits. I studied it in school, and I’ve built up experience—and a lot of fun stories—over the years.
I’ve always enjoyed the challenge of figuring out how things work—and more importantly, why they don’t. Whether it’s a broken wire or a broken workflow, I enjoy digging in and making it work again.

## Foundation

My approach to problem solving is built on a strong foundation in electronics. That’s where I first learned to isolate issues, trace signals, and find faults using logic and observation. Over time, I’ve carried those skills into working with code, systems, and machines. I usually start by looking for clarity—understanding how a normal state should work. Once I see that, it’s easier to spot what’s broken.

## Electronics

This is where it started for me. Debugging electronics taught me to be patient, methodical, and observant. I’ve learned to look for small signs: a voltage drop, a pattern glitch, or a warm component. I don't just test for failure—I try to understand the conditions around it.

Here’s my typical workflow when approaching an electronic issue:

1. Visual inspection
2. Feel for heat
3. Smell (burnt or chemical smells can say a lot)
4. Check obvious voltages and grounds (GND should always be 0 V—if it’s floating, it won’t show correctly)
5. I primarily test using voltage. From that, I can calculate current and find shorts or broken connections.

### Favorite Test Tools

- **Scope** - for seeing what the system won't tell you
- **Freeze spray** - for catching thermal issues
- **Short wire** - to bypass or bridge suspected faults
- **Square wave test** - for tracing signals across boards
- **Isopropanol or rosin atomizer** - to detect hot spots or weak joints

## Code / Systems

When it comes to code or system-level problems, I apply the same mindset: isolate, test, observe. I avoid assumptions, and I like to start by asking: _What should this actually do?_ Then I compare that to what’s happening. Whether I’m debugging firmware or troubleshooting automation scripts, I treat it like signal tracing—just in a different language.

## Machines

Machines are a different kind of system, but the thinking is the same. I listen for changes in sound, check physical wear, and look for patterns in failure. I treat mechanical troubleshooting as a conversation—the machine is giving signals, you just have to pay attention.

## General

No matter the problem, I try to avoid jumping to conclusions. I prefer to slow down, observe carefully, and start with what I know. I often sketch out the system or talk it through out loud—anything to get it out of my head and into something I can interact with.

I don’t aim for elegant solutions right away. I aim for understanding. Once I have that, the fix usually follows.

I also believe in testing early. If I have a hunch, I try to prove or disprove it with minimal effort before diving deeper. It saves time, avoids guesswork, and usually leads me somewhere useful—even if it’s not where I expected.

## Fixing

After identifying the problem, I work on a fix and decide whether it’s acceptable long-term—depending on how critical the system is. Sometimes a temporary solution is fine as long as it buys time until the proper spare part can be sourced.

![fix](https://scontent-dus1-1.xx.fbcdn.net/v/t39.30808-6/464415840_10230143669082973_2411371902132255510_n.jpg?_nc_cat=102&ccb=1-7&_nc_sid=cf85f3&_nc_ohc=g7yNtr6fQ-YQ7kNvwH7ocak&_nc_oc=Adk0nTxMNNZVV4iqpBmSSptT3igwrZqy2zOl2hpsNtfAIxhndz9BqqrPghsQeYfNADM&_nc_zt=23&_nc_ht=scontent-dus1-1.xx&_nc_gid=2o_ZdUTWhTM3qyo5I0oRRQ&oh=00_AfHucd-FGRl_B5sgWFtD4pR4HvOo8uyCwQNibAMiV2HlCA&oe=6808C6CE)

> One memorable on-the-spot fix: five minutes before going live, the broadcast mast wouldn’t raise. I quickly identified a faulty relay, grabbed a screwdriver, shorted it—and we went live on time.
